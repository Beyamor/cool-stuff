// Generated by CoffeeScript 1.3.3
(function() {
  var Boid, Canvas, boidColors, bounds, canvas, color, flock, i, pos, random, vector, _i, _ref,
    __slice = [].slice;

  vector = {
    add: function() {
      var dimension, result, sum, v, vs, _i, _j, _len, _ref;
      vs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      result = [];
      for (dimension = _i = 0, _ref = vs[0].length; 0 <= _ref ? _i < _ref : _i > _ref; dimension = 0 <= _ref ? ++_i : --_i) {
        sum = 0;
        for (_j = 0, _len = vs.length; _j < _len; _j++) {
          v = vs[_j];
          sum += v[dimension];
        }
        result.push(sum);
      }
      return result;
    },
    length: function(v) {
      return Math.sqrt(vector.lengthSquared(v));
    },
    lengthSquared: function(v) {
      return v.reduce(function(sum, x) {
        return sum + x * x;
      }, 0);
    },
    distanceSquared: function(v1, v2) {
      return vector.lengthSquared(vector.subtract(v1, v2));
    },
    subtract: function(v1, v2) {
      var dimension, result, _i, _ref;
      result = [];
      for (dimension = _i = 0, _ref = v1.length; 0 <= _ref ? _i < _ref : _i > _ref; dimension = 0 <= _ref ? ++_i : --_i) {
        result.push(v1[dimension] - v2[dimension]);
      }
      return result;
    },
    scale: function(v, scale) {
      return v.map(function(x) {
        return x * scale;
      });
    },
    direction: function(v) {
      return Math.atan2(v[1], v[0]);
    },
    clampLength: function(v, clampedLength) {
      var clamptScale, length, lengthSquared;
      lengthSquared = vector.lengthSquared(v);
      if (lengthSquared < clampedLength * clampedLength) {
        return v;
      }
      length = Math.sqrt(lengthSquared);
      clamptScale = clampedLength / length;
      return vector.scale(v, clamptScale);
    }
  };

  Canvas = (function() {

    function Canvas(id) {
      this.el = document.getElementById(id);
      this.width = parseInt(this.el.getAttribute("width"));
      this.height = parseInt(this.el.getAttribute("height"));
      this.context = this.el.getContext("2d");
      this.clearColor = "black";
    }

    Canvas.prototype.drawRect = function(x, y, width, height, color) {
      this.context.fillStyle = color;
      return this.context.fillRect(x, y, width, height);
    };

    Canvas.prototype.drawTriangle = function(_arg, _arg1, _arg2, color) {
      var x1, x2, x3, y1, y2, y3;
      x1 = _arg[0], y1 = _arg[1];
      x2 = _arg1[0], y2 = _arg1[1];
      x3 = _arg2[0], y3 = _arg2[1];
      this.context.beginPath();
      this.context.moveTo(x1, y1);
      this.context.lineTo(x2, y2);
      this.context.lineTo(x3, y3);
      this.context.lineTo(x1, y1);
      this.context.fillStyle = color;
      return this.context.fill();
    };

    Canvas.prototype.clear = function() {
      return this.drawRect(0, 0, this.width, this.height, this.clearColor);
    };

    return Canvas;

  })();

  random = function() {
    return Math.random();
  };

  random.posOrNeg = function() {
    return random() < 0.5;
  };

  random.inRange = function(min, max) {
    return min + random() * (max - min);
  };

  Boid = (function() {

    function Boid(flock, position, color, bounds) {
      var vx, vy;
      this.flock = flock;
      this.position = position;
      this.color = color;
      this.bounds = bounds;
      vx = random.inRange(0.5, 1) * random.posOrNeg();
      vy = random.inRange(0.5, 1) * random.posOrNeg();
      this.velocity = [vx, vy];
    }

    Boid.prototype.update = function() {
      var boid, c1, difference, inverseFlockSize, inwardVel, inwardVelX, inwardVelY, v1, v2, v3, x, y, _i, _len, _ref, _ref1;
      _ref = this.position, x = _ref[0], y = _ref[1];
      inverseFlockSize = 1.0 / (this.flock.length - 1);
      c1 = [0, 0];
      v2 = [0, 0];
      v3 = [0, 0];
      _ref1 = this.flock;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        boid = _ref1[_i];
        if (!(boid !== this)) {
          continue;
        }
        c1 = vector.add(c1, boid.position);
        if (vector.distanceSquared(this.position, boid.position) < 1000) {
          v2 = vector.subtract(v2, vector.subtract(boid.position, this.position));
        }
        v3 = vector.add(v3, boid.velocity);
      }
      c1 = vector.scale(c1, inverseFlockSize);
      difference = vector.subtract(c1, this.position);
      v1 = vector.scale(difference, 0.001);
      v2 = vector.scale(v2, 0.125);
      v3 = vector.scale(v3, inverseFlockSize);
      v3 = vector.scale(vector.subtract(v3, this.velocity), 0.0125);
      inwardVelX = x < bounds.minX ? 1 : x > bounds.maxX ? -1 : 0;
      inwardVelY = y < bounds.minY ? 1 : y > bounds.maxY ? -1 : 0;
      inwardVel = [inwardVelX, inwardVelY];
      this.velocity = vector.add(this.velocity, v1, v2, v3, inwardVel);
      this.velocity = vector.clampLength(this.velocity, 5);
      return this.position = vector.add(this.position, this.velocity);
    };

    Boid.prototype.draw = function(canvas) {
      var direction, p1, p2, p3, tailDirection1, tailDirection2, x, y, _ref;
      _ref = this.position, x = _ref[0], y = _ref[1];
      direction = vector.direction(this.velocity);
      tailDirection1 = direction + Math.PI * 0.75;
      tailDirection2 = direction - Math.PI * 0.75;
      p1 = vector.add(this.position, [Math.cos(direction) * 10, Math.sin(direction) * 10]);
      p2 = vector.add(this.position, [Math.cos(tailDirection1) * 5, Math.sin(tailDirection1) * 5]);
      p3 = vector.add(this.position, [Math.cos(tailDirection2) * 5, Math.sin(tailDirection2) * 5]);
      return canvas.drawTriangle(p1, p2, p3, this.color);
    };

    return Boid;

  })();

  canvas = new Canvas("boids");

  canvas.clearColor = "#202638";

  canvas.clear();

  boidColors = ["#61E6E8", "#E8C061", "#F2C2E0"];

  bounds = {
    minX: 0,
    maxX: canvas.width,
    minY: 0,
    maxY: canvas.height
  };

  flock = [];

  for (i = _i = 0, _ref = Math.floor(40 + 20 * Math.random()); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    pos = [Math.random() * canvas.width, Math.random() * canvas.height];
    color = boidColors[i % boidColors.length];
    flock.push(new Boid(flock, pos, color, bounds));
  }

  setInterval(function() {
    var boid, _j, _len, _results;
    canvas.clear();
    _results = [];
    for (_j = 0, _len = flock.length; _j < _len; _j++) {
      boid = flock[_j];
      boid.update();
      _results.push(boid.draw(canvas));
    }
    return _results;
  }, 16);

}).call(this);
