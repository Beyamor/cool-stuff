// Generated by CoffeeScript 1.3.3
(function() {
  var Canvas, Entity, Game, Steerer, Vec2, canvas, entity, game, programSettings;

  programSettings = {
    drawBoundingSphere: true
  };

  Vec2 = (function() {

    function Vec2(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    Vec2.prototype.clone = function() {
      return new Vec2(this.x, this.y);
    };

    Vec2.prototype.plus = function(other) {
      return new Vec2(this.x + other.x, this.y + other.y);
    };

    Vec2.prototype.minus = function(other) {
      return new Vec2(this.x - other.x, this.y - other.y);
    };

    Vec2.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y;
    };

    Vec2.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec2.prototype.direction = function() {
      return Math.atan2(this.y, this.x);
    };

    Vec2.prototype.scaleBy = function(scale) {
      return new Vec2(this.x * scale, this.y * scale);
    };

    Vec2.prototype.clamp = function(maxLength) {
      if (this.lengthSquared() <= maxLength * maxLength) {
        return this.clone();
      } else {
        return this.scaleBy(maxLength / this.length());
      }
    };

    Vec2.prototype.isZero = function() {
      return this.x === 0 && this.y === 0;
    };

    Vec2.prototype.normal = function() {
      return this.scaleBy(1 / this.length());
    };

    return Vec2;

  })();

  Canvas = (function() {

    function Canvas(id) {
      this.el = document.getElementById(id);
      this.width = parseInt(this.el.getAttribute("width"));
      this.height = parseInt(this.el.getAttribute("height"));
      this.context = this.el.getContext("2d");
      this.clearColor = "white";
    }

    Canvas.prototype.drawRect = function(x, y, width, height, color) {
      this.context.fillStyle = color;
      return this.context.fillRect(x, y, width, height);
    };

    Canvas.prototype.drawTriangle = function(_arg, _arg1, _arg2, color) {
      var x1, x2, x3, y1, y2, y3;
      x1 = _arg[0], y1 = _arg[1];
      x2 = _arg1[0], y2 = _arg1[1];
      x3 = _arg2[0], y3 = _arg2[1];
      this.context.beginPath();
      this.context.moveTo(x1, y1);
      this.context.lineTo(x2, y2);
      this.context.lineTo(x3, y3);
      this.context.lineTo(x1, y1);
      this.context.fillStyle = color;
      return this.context.fill();
    };

    Canvas.prototype.outlineCircle = function(x, y, radius, color) {
      this.context.beginPath();
      this.context.arc(x, y, radius, 0, 2 * Math.PI, false);
      this.context.strokeStyle = color;
      return this.context.stroke();
    };

    Canvas.prototype.clear = function() {
      return this.drawRect(0, 0, this.width, this.height, this.clearColor);
    };

    return Canvas;

  })();

  Steerer = (function() {

    function Steerer(game, entity, maxForce) {
      this.game = game;
      this.entity = entity;
      this.maxForce = maxForce;
      this.isOn = {
        seek: false,
        arrive: true
      };
    }

    Steerer.prototype.force = function() {
      var desiredVelocity, distance, force, speed, targetPos, toTarget;
      force = new Vec2;
      targetPos = this.game.mousePos;
      toTarget = targetPos.minus(this.entity.pos);
      if (this.isOn["seek"]) {
        desiredVelocity = toTarget.normal().scaleBy(this.entity.maxSpeed);
        force = desiredVelocity.minus(this.entity.vel);
      }
      if (this.isOn["arrive"]) {
        distance = toTarget.length();
        if (distance > 0) {
          speed = Math.min(this.entity.maxSpeed, distance);
          desiredVelocity = toTarget.normal().scaleBy(speed);
          force = desiredVelocity.minus(this.entity.vel);
        }
      }
      return force.clamp(this.maxForce);
    };

    return Steerer;

  })();

  Entity = (function() {

    function Entity(game, initialX, initialY) {
      this.pos = new Vec2(initialX, initialY);
      this.vel = new Vec2;
      this.invMass = 50;
      this.maxSpeed = 150;
      this.maxTurnRate = 1;
      this.steerer = new Steerer(game, this, 20);
      this.heading = 0;
      this.radius = 32;
    }

    Entity.prototype.update = function(timeDelta) {
      var acceleration;
      acceleration = this.steerer.force().scaleBy(this.invMass);
      this.vel = this.vel.plus(acceleration.scaleBy(timeDelta)).clamp(this.maxSpeed);
      this.pos = this.pos.plus(this.vel.scaleBy(timeDelta));
      if (this.vel.lengthSquared() > 0.0000001) {
        return this.heading = this.vel.direction();
      }
    };

    Entity.prototype.draw = function(canvas) {
      var headLength, tailAngle, tailLength, x, y;
      x = this.pos.x;
      y = this.pos.y;
      if (programSettings.drawBoundingSphere) {
        canvas.outlineCircle(x, y, this.radius, "grey");
      }
      headLength = this.radius;
      tailLength = this.radius - 5;
      tailAngle = 2.2;
      return canvas.drawTriangle([x + Math.cos(this.heading) * headLength, y + Math.sin(this.heading) * headLength], [x + Math.cos(this.heading - tailAngle) * tailLength, y + Math.sin(this.heading - tailAngle) * tailLength], [x + Math.cos(this.heading + tailAngle) * tailLength, y + Math.sin(this.heading + tailAngle) * tailLength], "black");
    };

    return Entity;

  })();

  Game = (function() {

    function Game(canvas) {
      var _this = this;
      this.canvas = canvas;
      this.entities = [];
      this.mousePos = new Vec2;
      this.canvas.el.addEventListener('mousemove', function(e) {
        var rect;
        rect = _this.canvas.el.getBoundingClientRect();
        return _this.mousePos = new Vec2(e.clientX - rect.left, e.clientY - rect.top);
      });
    }

    Game.prototype.update = function(timeDelta) {
      var entity, _i, _len, _ref, _results;
      _ref = this.entities;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        _results.push(entity.update(timeDelta));
      }
      return _results;
    };

    Game.prototype.draw = function() {
      var entity, _i, _len, _ref, _results;
      canvas.clear();
      _ref = this.entities;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        _results.push(entity.draw(this.canvas));
      }
      return _results;
    };

    Game.prototype.run = function() {
      var currentTime,
        _this = this;
      currentTime = new Date().getTime() / 1000;
      return setInterval(function() {
        var previousTime, timeDelta;
        previousTime = currentTime;
        currentTime = new Date().getTime() / 1000;
        timeDelta = currentTime - previousTime;
        _this.update(timeDelta);
        return _this.draw();
      }, 16);
    };

    return Game;

  })();

  canvas = new Canvas("aa");

  game = new Game(canvas);

  entity = new Entity(game, canvas.width / 2, canvas.height / 2);

  game.entities.push(entity);

  game.run();

}).call(this);
